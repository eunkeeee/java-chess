# java-chess

체스 미션 저장소

## 우아한테크코스 코드리뷰

- [온라인 코드 리뷰 과정](https://github.com/woowacourse/woowacourse-docs/blob/master/maincourse/README.md)

# 기능 명세서

## 체스판 초기화

### 체스말

- [x] 체스말은 위치를 가지고 있다.
- [x] 흑, 백으로 구분할 수 있다.
- [x] 체스 말의 종류에는 폰, 룩, 나이트, 비숍, 퀸, 킹이 있다.
- [x] 특정 체스말이 특정 위치로 이동이 가능한지 알 수 있다.
- [x] 특정 체스말이 특정 위치로 이동하는 경로를 알 수 있다.
- [x] 체스말의 도착지에 다른 체스말이 있는지 알 수 있다.
    - [x] 도착지에 상대 말이 있으면 이동할 수 있다.
    - [x] 도착지에 같은 말이 있으면 이동할 수 없다.

### 체스판

- [x] 체스말들을 가지고 있다.
- [x] 체스말들의 위치를 가지고 있다.
- [x] 체스말이 반환한 경로 안에 다른 체스말이 있는지 알 수 있다.
    - [x] 반환한 경로(도착지 미포함) 안에 다른 체스말이 있다면 이동할 수 없다.

- [x] 상대편 `King`이 잡히는 경우 게임을 종료한다.
- [x] 현재 남아 있는 말에 대해서 점수를 구할 수 있다.
    - [x] 각 말의 점수는 queen은 9점, rook은 5점, bishop은 3점, knight는 2.5점이다.
    - [x] pawn의 기본 점수는 1점이다. 하지만 같은 세로줄에 같은 색의 폰이 있는 경우 1점이 아닌 0.5점을 준다.

### `Pawn`

- [x] 도착지에 상대 말이 있으면 대각선으로 이동할 수 있다.
- [x] 도착지에 말이 없으면 전진할 수 있다.
    - [x] 처음 상태에서는 1칸, 혹은 2칸 전진할 수 있다.
    - [x] 처음 상태가 아니면 1칸 전진할 수 있다.

### 데이터베이스 연결

    ```sql

    CREATE TABLE chess_status (
        game_id INT AUTO_INCREMENT,
        turn VARCHAR(255) NOT NULL,
        PRIMARY KEY (game_id)
    );

    CREATE TABLE chess_game (
        position VARCHAR(255) NOT NULL,
        piece_type VARCHAR(255),
        piece_color VARCHAR(255),
        game_id INT NOT NULL,
        piece_id INT AUTO_INCREMENT,
        PRIMARY KEY (piece_id)
    );

    ```

#### 1, 2단계 리팩터링 목록

- [x] 테스트 `DisplayName` 적기
- [x] 디디: View로 도메인을 그대로 넘기는것은 View와 도메인간 의존성을 가지게 합니다. 중간객체나 원시값으로 바꿔볼까요?
- [x] 디디: 파라미터의 인덱스가 어떤건지 이해하기 좋을까요? 차라리 moveCommand의 특정인덱스 값을 파라미터로 넘기는게 나아보여요
- [x] `Piece`의 중복되는 내용 `default`로 상위 클래스에서 제공하고 필요한 데서만 오버라이딩하기
- [x] 도메인의 모든 발생 가능한 예외는 검증되어야 합니다.
- [x] 허브: 랭크나 파일에 메시지를 던져보는건 어떨까요?
- [x] 디디: 파라미터에 `Optional`을 사용하는 것은 안티패턴

#### 3단계 질문

1. 상위 클래스에서 최대한 하위 클래스에 대해서 모른 채로 공통된 명령을 내리는 방식으로 객체를 설계하고 싶습니다.
   하지만, `Pawn`을 점수를 계산할 때, 꼭 한 번은 더 높은 추상 클래스라고 볼 수 있는 `Board`에서 어떤 방법으로든 한 번은 `File`에 따라 정렬한 `Pieces` 중 `Pawn`이 두 개 이상
   있는 지 검사해야 합니다.
   이 때에 캡슐화가 깨지고 있는데, `instance of`를 사용하고 싶지 않아서 `Piece`에 `PieceType`이라고 하는 새로운 필드를 정의했습니다.
   이 경우에도 캡슐화가 깨진다고 할 수 있을까요? 더 좋은 방법이 있을까요?

2. 마찬가지로, 게임의 종료 조건을 검사할 때에도 `King`이 죽었는 지를 알기 위해서는 상위 클래스에서 구체 클래스 `King`을 드러내 검사할 수밖에 없습니다.

#### 3, 4단계 리팩터링 목록

- [x] 점수 무승부 구현하기
- [x] PieceType의 Field로 Function을 가지면 가능할것 같아요 :)
- [x] Piece는 Piece 그 자체이고, 세로줄(File)이라는 개념은 별도의 객체가 가지고 있어야 한다는 말이었습니다.
- [x] DB 연결 실패 시 null을 리턴하기보단 예외를 던져주면 좋을것 같아요. nullPointerException을 마주치면 당황스럽겠죠?
- [ ] InMemoryDB 를 test패키지로 이동시키고, 그걸가지고 CRUD를 테스트 하시는게 좋을것 같아요.
